{"version":3,"sources":["../src/__prologue__.js","../src/hypothesis-testing.js","../src/__epilogue__.js","../src/Scanner.js"],"names":["__init__","base","Sermat","ludorum","raiseIf","declare","initialize","iterable","Iterable","Randomness","Future","Statistics","exports","__package__","__name__","__dependencies__","__SERMAT__","include","statistics","compare","args","game","intervalId","players","RandomPlayer","name","opponents","matchCount","logger","contests","map","player","tournaments","Measurement","info","length","matchesPlayed","forEach","contest","events","on","setInterval","logTime","all","run","then","i","stats","r","role","count","key","toObject","clearInterval","hypergeometricRule","row1","row2","n","rowSums","colSums","v","factors","Array","concat","x","fi","di","Math","pow","fisher2x2","alpha","isNaN","a","b","c","d","r1","r2","c1","cutoff","abs","max_a","min","p_value","comparison","fisher2x3","p","max_b","e","f","c2","c3","row","Scanner","constructor","config","this","object","ignore","integer","defaultValue","coerce","DEFAULT","bool","scan","scanner","window","arguments","prototype","slice","call","ply","__currentWidth__","maxLength","whileDo","__advance__","level","filter","nexts","isEmpty","adjustWidth","flatten","sample","random","toArray","add","scans","sequence","bind","isContingent","possibleHaps","mapApply","haps","prob","next","account","EMPTY","moves","activePlayers","decisionTime","stat","startTime","when","decision","move","addTime","decisions","product","apply","result","static scan"],"mappings":"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","file":"ludorum-player-assess-tag.min.js","sourcesContent":["/** Library wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar raiseIf = base.raiseIf,\n\t\tdeclare = base.declare,\n\t\tinitialize = base.initialize,\n\t\titerable = base.iterable,\n\t\tIterable = base.Iterable,\n\t\tRandomness = base.Randomness,\n\t\tFuture = base.Future,\n\t\tStatistics = base.Statistics;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t\t__package__: 'ludorum-player-assess',\n\t\t\t__name__: 'ludorum_player_assess',\n\t\t\t__init__: __init__,\n\t\t\t__dependencies__: [base, Sermat], ludorum,\n\t\t\t__SERMAT__: { include: [base, ludorum] }\n\t\t},\n\t\t/* Namespace for statistical functions and utilities */\n\t\tstatistics = exports.statistics = { }\n\t;","/** # Independence test\n\nPlayer performance comparisons and tests based on hypothesis testing.\n*/\n\nexports.compare = function compare(args) {\n\traiseIf(!args || !args.game, \"Missing `game` argument!\");\n\tvar game = args.game,\n\t\tplayers = args.players || [new ludorum.players.RandomPlayer({ name: 'RandomPlayer' })],\n\t\topponents = args.opponents || [new ludorum.players.RandomPlayer({ name: 'RandomOpponent' })],\n\t\tmatchCount = +args.matchCount || 400,\n\t\tlogger = args.logger,\n\t\tcontests = players.map(function (player) {\n\t\t\treturn new ludorum.tournaments.Measurement(game, player, opponents, matchCount);\n\t\t}),\n\t\tintervalId;\n\tif (logger) {\n\t\tlogger.info(\"Starting \"+ matchCount * players.length * 2 +\" matches of \"+ game.name +\".\");\n\t\tvar matchesPlayed = 0;\n\t\tcontests.forEach(function (contest) { \n\t\t\tcontest.events.on('afterMatch', function () {\n\t\t\t\tmatchesPlayed++;\n\t\t\t});\n\t\t});\n\t\tintervalId = setInterval(function () {\n\t\t\tlogger.info(\"Played \"+ matchesPlayed +\"/\"+ matchCount * players.length * 2 +\" matches.\");\n\t\t}, args.logTime || 20000);\n\t}\n\treturn base.Future.all(contests.map(function (contest) {\n\t\treturn contest.run();\n\t})).then(function () {\n\t\treturn contests.map(function (contest, i) {\n\t\t\tvar stats = contest.statistics,\n\t\t\t\tplayer = players[i],\n\t\t\t\tr = base.iterable(game.players).map(function (role) {\n\t\t\t\t\treturn [role, [\n\t\t\t\t\t\tstats.count({ key: 'victories', role: role, player: player.name }),\n\t\t\t\t\t\tstats.count({ key: 'draws',     role: role, player: player.name }),\n\t\t\t\t\t\tstats.count({ key: 'defeats',   role: role, player: player.name })\n\t\t\t\t\t]];\n\t\t\t\t}).toObject();\n\t\t\tr.player = player.name;\n\t\t\treturn r;\n\t\t});\n\t}).then(function (r) {\n\t\tif (logger) {\n\t\t\tclearInterval(intervalId);\n\t\t\tlogger.info(\"Played \"+ matchesPlayed +\"/\"+ matchCount * players.length * 2 +\" matches.\");\n\t\t}\n\t\treturn r;\n\t});\n};\n\n// ## Fisher exact test ############################################################################\n\n/** Part of Fisher's exact test is the hypergeometric rule, which is used to calculate the \nprobability of a given contingency table.\n\nThe formula is $ p=\\frac{(a+b)!(c+d)!(a+c)!(b+d)!}{a!b!c!d!n!} $. Calculating all factorials can \noverflow the 64 bits double floating point precision, and even if it does not is quite inefficient. \nThis algorithm lists all factors (and divisors), simplifying the calculation as much as possible, \nand ordering multiplications and divisions to minimize the chance of overflow.\n*/\nvar hypergeometricRule = statistics.hypergeometricRule = function hypergeometricRule(row1, row2) {\n    var n = 0,\n        rowSums = [0, 0],\n        colSums = row1.map(function (v, i) {\n            rowSums[0] += v;\n            rowSums[1] += row2[i];\n            n += v + row2[i];\n            return v + row2[i];\n        });\n    var factors = new Array(n + 1);\n    rowSums.concat(colSums).forEach(function (x) {\n        for (var i = 2; i <= x; i++) {\n            factors[i] = (factors[i] |0) + 1;\n        }\n    });\n    [n].concat(row1, row2).forEach(function (x) {\n        for (var i = 2; i <= x; i++) {\n            factors[i] = (factors[i] |0) - 1;\n        }\n    });\n    var r = 1;\n    for (var fi = 2, di = 2; fi <= n || di <= n; ) {\n        if (r <= 1 && fi <= n) {\n            if (factors[fi] > 0) {\n                r *= Math.pow(fi, factors[fi]);\n            }\n            fi++;\n        } else {\n            if (factors[di] < 0) {\n                r *= Math.pow(di, factors[di]);\n            }\n            di++;\n        }\n    }\n    return r;\n};\n\n/** Fisher's exact test for contingency tables of 2 rows per 2 columns. Both arguments `row1` and\n`row2` must be arrays of two possitive integers, and `alpha` indicates the significance of the\nhypothesis test (5% or 0.05 by default).\n\nThe result is an object with:\n\n+ `p_value`: The _p_ value for the test.\n\n+ `comparison`: A number complaint with sorting functions (i.e. negative if `row1` is less than \n`row2`, possitive if `row1` is greater than `row2`, zero otherwise). If the p value is greater than\n`alpha` the comparison is zero, else the difference of the values of the first column is returned.\n*/\nstatistics.fisher2x2 = function fisher2x2(row1, row2, alpha) {\n    raiseIf(row1.length !== 2 || row2.length !== 2, \"Contingency table should be 2x2!\");\n    alpha = isNaN(alpha) ? 0.05 : +alpha;\n    var a = row1[0], b = row1[1],\n        c = row2[0], d = row2[1],\n        r1 = a + b, r2 = c + d,\n        c1 = a + c, c2 = b + d,\n\t   cutoff = Math.abs(a / r1 - c / r2),\n\t   max_a = Math.min(r1, c1),\n        p_value = 0,\n        disprop, p;\n    for (a = 0; a <= max_a; a++) {\n\t\tb = r1 - a;\n\t\tc = c1 - a;\n\t\td = r2 - c;\n\t\tif (d >= 0) {\n\t\t\tdisprop = Math.abs(a / r1 - c / r2);\n\t\t\tif (disprop >= cutoff) {\n\t\t\t\tp = hypergeometricRule([a, b], [c, d]);\n\t\t\t\tp_value += p;\n\t\t\t}\n\t\t}\n    }\n    return {\n        p_value: p_value,\n        comparison: p_value > alpha ? 0 : (row1[0] - row2[0])\n    };\n};\n\n/** Fisher's exact test for contingency tables of 2 rows per 3 columns. Both arguments `row1` and\n`row2` must be arrays of three possitive integers, and `alpha` indicates the significance of the\nhypothesis test (5% or 0.05 by default).\n\nThe result is an object with:\n\n+ `p_value`: The _p_ value for the test.\n\n+ `comparison`: A number complaint with sorting functions (i.e. negative if `row1` is less than \n`row2`, possitive if `row1` is greater than `row2`, zero otherwise). If the p value is greater than\n`alpha` the comparison is zero. Else the difference of the values of the first column is returned if\nnot zero. Else the difference of the values of the second column normalized between 0 and 1 is \nreturned.\n*/\nstatistics.fisher2x3 = function fisher2x3(row1, row2, alpha) {\n\traiseIf(row1.length !== 3 || row2.length !== 3, \"Contingency table should be 2x3!\");\n\talpha = isNaN(alpha) ? 0.05 : +alpha;\n\tvar a = row1[0], b = row1[1], c = row1[2],\n\t\td = row2[0], e = row2[1], f = row2[2],\n\t\tr1 = a + b + c, r2 = d + e + f,\n\t\tc1 = a + d, c2 = b + e, c3 = c + f,\n\t\tcutoff = hypergeometricRule([a, b, c], [d, e, f]),\n\t\tmax_a = Math.min(r1, c1),\n\t\tp_value = 0,\n\t\tp, max_b;\n\tfor (a = 0; a <= max_a; a++) {\n\t\tmax_b = Math.min(r1 - a, c2);\n\t\tfor (b = 0; b <= max_b; b++) {\n\t\t\tc = r1 - a - b;\n\t\t\td = c1 - a;\n\t\t\te = c2 - b;\n\t\t\tf = c3 - c;\n\t\t\tif (f >= 0) {\n\t\t\t\tp = hypergeometricRule([a, b, c], [d, e, f]);\n\t\t\t\tif (p <= cutoff) {\n\t\t\t\t\tp_value += p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tp_value: p_value,\n\t\tcomparison: p_value > alpha ? 0 : (row1[0] - row2[0] || (row1[1] - row[1]) / (c2 + 1))\n\t};\n};","// See __prologue__.js\n\treturn exports;\n}\n","/** # Scanner\n\nComponent for scanning a game's tree.\n*/\nexports.Scanner = declare({\n\t/** A Scanner builds a sample of a game tree, in order to get statistics from some of all\n\tpossible matches. The given `config` must have:\n\t*/\n\tconstructor: function Scanner(config) {\n\t\tinitialize(this, config)\n\t\t/** + `game`: Game to scan.\n\t\t*/\n\t\t\t.object('game', { ignore: true })\n\t\t/** + `maxWidth=1000`: Maximum amount of game states held at each step.\n\t\t*/\n\t\t\t.integer('maxWidth', { defaultValue: 1000, coerce: true })\n\t\t/** + `maxLength=50`: Maximum length of simulated matches.\n\t\t*/\n\t\t\t.integer('maxLength', { defaultValue: 50, coerce: true })\n\t\t/** + `random=randomness.DEFAULT`: Pseudorandom number generator to use in the simulations.\n\t\t*/\n\t\t\t.object('random', { defaultValue: Randomness.DEFAULT })\n\t\t/** + `statistics=<new>`: Component to gather relevant statistics.\n\t\t*/\n\t\t\t.object('statistics', { defaultValue: new Statistics() })\n\t\t/** + `adjustWidth`: Reduce the width of the scan window for every final state found.\n\t\t*/\n\t\t\t.bool('adjustWidth', { defaultValue: false, coerce: true });\n\t},\n\t\n\t/** A scan of a game's tree reproduces and samples the set of all possible matches from the\n\tgiven game states. The simulation halts at `maxLength` plies, and never holds more than \n\t`maxWidth` game states. Since this process is asynchronous, this method returns a future.\n\t\n\tThe `players` argument may provide a player for some or all of the games' roles. If available,\n\tthey will be used to decide which move is applied to each game state. If missing, all next game\n\tstates will be added. Ergo no players means a simulation off all possible matches.\t\t\n\t*/\n\tscan: function scan(players) {\n\t\tvar scanner = this,\n\t\t\twindow = arguments.length < 2 ? \n\t\t\t\t(this.game ? [this.game] : []) : \n\t\t\t\tArray.prototype.slice.call(arguments, 1),\n\t\t\tply = 0;\n\t\tthis.__currentWidth__ = this.maxLength;\n\t\treturn Future.whileDo(function () {\n\t\t\treturn window.length > 0 && ply < scanner.__currentWidth__;\n\t\t}, function () {\n\t\t\treturn Future.all(window.map(function (game) {\n\t\t\t\treturn scanner.__advance__(players, game, ply);\n\t\t\t})).then(function (level) {\n\t\t\t\twindow = iterable(level).filter(function (nexts) {\n\t\t\t\t\t\tvar isEmpty = nexts.isEmpty();\n\t\t\t\t\t\tif (isEmpty && scanner.adjustWidth) {\n\t\t\t\t\t\t\tscanner.__currentWidth__--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn !isEmpty;\n\t\t\t\t\t})\n\t\t\t\t\t.flatten()\n\t\t\t\t\t.sample(scanner.__currentWidth__, scanner.random)\n\t\t\t\t\t.toArray();\n\t\t\t\treturn ++ply;\n\t\t\t});\n\t\t}).then(function () {\n\t\t\tscanner.statistics.add({ key:'aborted' }, window.length);\n\t\t\treturn scanner.statistics;\n\t\t});\n\t},\n\t\n\t/** Performs scans for many different player setups.\n\t*/\n\tscans: function scans() {\n\t\treturn Future.sequence(Array.prototype.slice.call(arguments), this.scan.bind(this));\n\t},\n\t\n\t/** The `__advance__` method advances the given game by one ply. This may mean for non final\n\tgame states either instantiate random variables, ask the available player for a decision, or \n\ttake all next game states. Final game states are removed. \n\t\n\tAll game states are accounted in the scanner's statistics. The result is an iterable with the \n\tgame states to add to the next scan window.\n\t*/\n\t__advance__: function __advance__(players, game, ply) {\n\t\tif (game.isContingent) {\n\t\t\treturn iterable(game.possibleHaps()).mapApply(function (haps, prob) {\n\t\t\t\treturn game.next(haps);\n\t\t\t});\n\t\t} else if (this.account(players, game, ply)) {\n\t\t\treturn Iterable.EMPTY;\n\t\t} else {\n\t\t\tvar moves = game.moves(),\n\t\t\t\tstats = this.statistics;\n\t\t\treturn Future.all(game.activePlayers.map(function (role) {\n\t\t\t\tif (players && players[role]) {\n\t\t\t\t\tvar p = players[role],\n\t\t\t\t\t\tdecisionTime = stats.stat({ key:'decision.time', game: game.name, \n\t\t\t\t\t\t\trole: role, player: p.name });\n\t\t\t\t\tdecisionTime.startTime();\n\t\t\t\t\treturn Future.when(p.decision(game, role)).then(function (move) {\n\t\t\t\t\t\tdecisionTime.addTime();\n\t\t\t\t\t\treturn [[role, move]];\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn moves[role].map(function (move) {\n\t\t\t\t\t\treturn [role, move];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})).then(function (decisions) {\n\t\t\t\treturn Iterable.product.apply(Iterable, decisions).map(function (moves) {\n\t\t\t\t\treturn game.next(iterable(moves).toObject());\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t},\n\t\t\t\n\t/** The `account` method gathers statistics about the game. These include:\n\t\t\n\t+ `game.result`: Final game state results. Also available for victory and defeat.\n\t+ `game.length`: Match length in plies. Also available for victory and defeat.\n\t+ `game.width`: Number of available moves.\n\t+ `draw.length`: Drawn match length in plies.\n\t\n\tReturns whether the given game state is final or not.\n\t*/\n\taccount: function account(players, game, ply) {\n\t\tvar result = game.result(),\n\t\t\tstats = this.statistics;\n\t\tif (result) {\n\t\t\titerable(game.players).forEach(function (role) {\n\t\t\t\tvar r = result[role],\n\t\t\t\t\tp = (players && players[role]) ? players[role].name : '';\n\t\t\t\tstats.add({ key:'game.result', game:game.name, role:role, player:p }, r, game);\n\t\t\t\tstats.add({ key:'game.length', game:game.name, role:role, player:p }, ply, game);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tstats.add({ key:'defeat.result', game:game.name, role:role, player:p }, r, game);\n\t\t\t\t\tstats.add({ key:'defeat.length', game:game.name, role:role, player:p }, ply, game);\n\t\t\t\t} else if (r > 0) {\n\t\t\t\t\tstats.add({ key:'victory.result', game:game.name, role:role, player:p }, r, game);\n\t\t\t\t\tstats.add({ key:'victory.length', game:game.name, role:role, player:p }, ply, game);\n\t\t\t\t} else {\n\t\t\t\t\tstats.add({ key:'draw.length', game:game.name, role:role, player:p }, ply, game);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t} else {\n\t\t\tvar moves = game.moves();\n\t\t\titerable(game.activePlayers).forEach(function (role) {\n\t\t\t\tstats.add({ key:'game.width', game:game.name, role:role }, moves[role].length);\n\t\t\t});\n\t\t\treturn false;\n\t\t}\n\t},\n\n\t/** Shortcut to scan a game. \n\t*/\n\t'static scan': function scan(config) {\n\t\treturn (new this(config)).scan(config.players);\n\t}\n}); // Scanner.\n"]}